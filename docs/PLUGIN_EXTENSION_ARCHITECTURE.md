# Plugin and Extension Architecture

This guide explains how to attach new agents to the BIOwerk mesh, how message envelopes are structured, and which shared utilities keep extensions production-ready.

## Overview
BIOwerk routes traffic through the mesh gateway (`mesh/main.py`) to agents. Agents receive normalized message envelopes (`matrix.models.Msg`) and return `matrix.models.Reply` objects. Shared utilities in `matrix/` provide observability, validation, and security that every extension should reuse.

## Hooking Agents into the Mesh
1. **Expose a FastAPI entrypoint** on your agent (e.g., `/v1/<agent>/plan` or `/v1/<agent>/run`). The mesh proxies requests to these paths.
2. **Register the agent URL** by configuring `AGENT_<NAME>_URL` (see `AGENT_URLS` in `mesh/main.py`). Keep the name lowercase to match routing keys.
3. **Health checks:** implement `GET /health` for your agent and ensure it returns `{ "status": "ok" }` with a 200 status. The mesh registers this endpoint with the distributed health manager during startup.
4. **Resilience and discovery:** the mesh wraps downstream calls with `ResilientHttpClient`, distributed circuit breakers, and load balancing. Agents do not need to reimplement these, but they should expose idempotent, retry-friendly handlers.
5. **Authentication/RBAC:** rely on mesh-provided auth; validate authorization claims again inside the agent for privileged actions.

### Minimal routing example (agent side)
```python
from fastapi import APIRouter, Depends
from matrix.models import Msg, Reply
from matrix.utils import state_hash
from matrix.logging_config import log_request, log_response

router = APIRouter(prefix="/v1/osteon")

@router.post("/plan", response_model=Reply)
async def plan(request: Msg) -> Reply:
    log_request(agent="osteon", intent=request.intent, payload=request.input)
    # business logic goes here
    output = {"steps": ["collect inputs", "draft plan"]}
    reply = Reply(
        id=request.id,
        ts=request.ts,
        agent="osteon",
        ok=True,
        output=output,
        state_hash=state_hash(output),
        api_version=request.api_version,
    )
    log_response(agent="osteon", intent=request.intent, payload=reply.model_dump())
    return reply
```
Mount the router inside your FastAPI application and ensure the service is reachable at the URL configured in `AGENT_URLS`.

## Message Envelopes
- **Request (`matrix.models.Msg`):**
  - `id`: UUID for correlation (generated by the sender if absent).
  - `ts`: epoch timestamp (float).
  - `origin`: caller identifier (service/user).
  - `target`: agent name (e.g., `osteon`).
  - `intent`: the operation (e.g., `plan`, `run`).
  - `input`: structured payload for the agent.
  - `api_version`: mesh API version (default `v1`).
- **Response (`matrix.models.Reply`):**
  - Mirrors the request `id`/`ts`, sets `agent`, `ok`, `output`, `state_hash`, and `api_version`.
  - Use `matrix.utils.state_hash` to generate deterministic hashes for replay safety.

### Example envelope from the demo runner
See `examples/demo_requests.json` and `examples/run_demo_requests.py` for ready-made payloads. Example request body:
```json
{
  "origin": "cli",
  "target": "osteon",
  "intent": "plan",
  "input": {"goal": "draft SOP"},
  "api_version": "v1"
}
```

## Shared Utilities to Reuse
- **Observability:** `matrix.logging_config` (structured logs) and `matrix.observability` (OTEL instrumentation) for tracing/metrics.
- **Validation:** `matrix.api_models` offers strict Pydantic schemas and helpers like `validate_safe_string` and `validate_safe_list`.
- **Security:** `matrix.audit` for event logging with `AuditContext`, `matrix.security_headers` middleware, and RBAC helpers in `matrix.auth_dependencies`.
- **Resilience:** `matrix.resilience` and `matrix.distributed_circuit_breaker` already wrap mesh calls; keep agent handlers idempotent and quick to unblock retries/bulkheads.

## Definition of Done for Extensions
- Declare supported BIOwerk and mesh API versions in the README and PR body.
- Add or update OpenAPI snapshots (`python scripts/export_openapi_snapshots.py`) for new endpoints.
- Emit audit events for privileged operations and ensure secrets are never logged.
- Provide rollback guidance and rate-limit expectations in the PR.
- Include automated tests for new routes plus load/chaos notes when applicable.
